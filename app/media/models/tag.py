"""
Tag model for categorizing media files.

Provides a flexible tagging system with three tag types:
- User tags: Created by users, scoped per-user (same name allowed for different users)
- System tags: Global, managed by admins/system
- Auto tags: Global, generated by processing pipeline (AI-detected labels, etc.)

The hybrid scoping model allows:
- Users to create personal tags without conflicts
- System-wide tags for organization-level categorization
- Automatic tagging from image recognition, OCR, etc.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from django.conf import settings
from django.db import models
from django.utils.text import slugify

from core.model_mixins import UUIDPrimaryKeyMixin
from core.models import BaseModel

if TYPE_CHECKING:
    pass


class Tag(UUIDPrimaryKeyMixin, BaseModel):
    """
    Tag for categorizing media files.

    Attributes:
        name: Display name of the tag.
        slug: URL-safe version of the name, used for lookups.
        tag_type: Type of tag (user, system, auto).
        category: Optional category for grouping tags (e.g., "color", "subject").
        color: Optional hex color code for UI display.
        owner: For user tags, the user who owns this tag. NULL for system/auto tags.

    Scoping Rules:
        - User tags (owner IS NOT NULL): Unique per (slug, owner)
        - System/Auto tags (owner IS NULL): Unique per slug globally

    Usage:
        # Create a user tag
        tag = Tag.objects.create(
            name="Vacation Photos",
            owner=user,
            tag_type=Tag.TagType.USER,
        )

        # Create a system tag (admin only)
        tag = Tag.objects.create(
            name="Featured",
            tag_type=Tag.TagType.SYSTEM,
        )

        # Auto-generated tags (created by processing pipeline)
        tag, _ = Tag.objects.get_or_create(
            slug="sunset",
            tag_type=Tag.TagType.AUTO,
            defaults={"name": "Sunset"},
        )
    """

    class TagType(models.TextChoices):
        """Types of tags with different scoping rules."""

        USER = "user", "User Created"
        SYSTEM = "system", "System"
        AUTO = "auto", "Auto-Generated"

    name = models.CharField(
        max_length=100,
        help_text="Display name of the tag",
    )

    slug = models.SlugField(
        max_length=100,
        db_index=True,
        help_text="URL-safe version of the name",
    )

    tag_type = models.CharField(
        max_length=20,
        choices=TagType.choices,
        default=TagType.USER,
        db_index=True,
        help_text="Type of tag (user, system, auto)",
    )

    category = models.CharField(
        max_length=50,
        blank=True,
        db_index=True,
        help_text="Optional category for grouping (e.g., 'color', 'subject', 'location')",
    )

    color = models.CharField(
        max_length=7,
        blank=True,
        help_text="Hex color code for UI display (e.g., '#FF5733')",
    )

    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="tags",
        help_text="Owner of user tags. NULL for system/auto tags.",
    )

    class Meta:
        verbose_name = "Tag"
        verbose_name_plural = "Tags"
        ordering = ["name"]

        indexes = [
            models.Index(fields=["owner", "slug"]),
            models.Index(fields=["tag_type", "category"]),
        ]

        constraints = [
            # User tags: unique per (slug, owner) when owner IS NOT NULL
            models.UniqueConstraint(
                fields=["slug", "owner"],
                condition=models.Q(owner__isnull=False),
                name="tag_unique_user_slug",
            ),
            # System/Auto tags: unique per slug when owner IS NULL
            models.UniqueConstraint(
                fields=["slug"],
                condition=models.Q(owner__isnull=True),
                name="tag_unique_global_slug",
            ),
            # Ensure user tags have an owner, system/auto tags don't
            models.CheckConstraint(
                check=(
                    models.Q(tag_type="user", owner__isnull=False)
                    | models.Q(tag_type__in=["system", "auto"], owner__isnull=True)
                ),
                name="tag_owner_type_consistency",
            ),
        ]

    def __str__(self) -> str:
        """Return tag name with type indicator if not user tag."""
        if self.tag_type == self.TagType.USER:
            return self.name
        return f"{self.name} [{self.get_tag_type_display()}]"

    def save(self, *args, **kwargs) -> None:
        """Auto-generate slug from name if not provided."""
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    @classmethod
    def get_or_create_user_tag(
        cls,
        name: str,
        owner,
        category: str = "",
        color: str = "",
    ) -> tuple["Tag", bool]:
        """
        Get or create a user tag for the given owner.

        This is the preferred way to create user tags as it handles
        slug generation and ensures proper scoping.

        Args:
            name: Display name for the tag.
            owner: User who owns this tag.
            category: Optional category for grouping.
            color: Optional hex color code.

        Returns:
            Tuple of (tag, created) where created is True if new tag was made.
        """
        slug = slugify(name)
        return cls.objects.get_or_create(
            slug=slug,
            owner=owner,
            tag_type=cls.TagType.USER,
            defaults={
                "name": name,
                "category": category,
                "color": color,
            },
        )

    @classmethod
    def get_or_create_auto_tag(
        cls,
        name: str,
        category: str = "",
        confidence: float | None = None,
    ) -> tuple["Tag", bool]:
        """
        Get or create an auto-generated tag.

        Used by the processing pipeline for AI-detected labels.

        Args:
            name: Display name for the tag.
            category: Optional category (e.g., "object", "scene").
            confidence: Not stored on tag itself, passed to MediaFileTag.

        Returns:
            Tuple of (tag, created) where created is True if new tag was made.
        """
        slug = slugify(name)
        return cls.objects.get_or_create(
            slug=slug,
            owner=None,
            tag_type=cls.TagType.AUTO,
            defaults={
                "name": name,
                "category": category,
            },
        )

    @property
    def is_user_tag(self) -> bool:
        """Check if this is a user-owned tag."""
        return self.tag_type == self.TagType.USER

    @property
    def is_system_tag(self) -> bool:
        """Check if this is a system tag."""
        return self.tag_type == self.TagType.SYSTEM

    @property
    def is_auto_tag(self) -> bool:
        """Check if this is an auto-generated tag."""
        return self.tag_type == self.TagType.AUTO
